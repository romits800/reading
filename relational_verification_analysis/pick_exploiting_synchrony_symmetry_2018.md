| **Title**         | Exploiting Synchrony and Symmetry in Relational Verification                                 |
|:-----------------:|----------------------------------------------------------------------------------------------|
| **Authors**       | Lauren Pick, Grigory Fedyukovich, Aarti Gupta                                                |
| **Venue**         | CAV'18                                                                                       |
| **Tool**          | Synonym                                                                                    |
| **Rel. Analysis** |                                      |
| **Invariant**     | Relational                                                                       |
| **Method**        | Model Checking                                                                       |
| **Reading level** |                                                                                     |


# Summary


Exploits 1) *synchrony* to align code fragments that are similar
(assume they are executed at the same time) that facilitates the
analysis and 2) *symmetry* to prune symmetric paths (inspired by SAT).
The task of relational verification is reduced to finding one
inductive invariant.


## CheckLockstep
- Input: set of programs with loops
- Output: set of maximal classes of programs that can be executed in
  lockstep

The algorithm first partitions the input programs and calls
**CheckLockstep** on the partitions.  The algorithm infers an
relational inductive invariant for the loop bodies.  Then tries to
prove that the termination of one loop implied the termination of all
loops.  To prove that, the respective query should be unsatisfiable
and then, the algorithm returns one class that contains all programs.
If the query is not satisfiable, the algorithm partitions in two sets,
one set that consists of the programs that have a satisfying
assignment for **guard** and the ones that do not.  The final set of
programs that can be executed in lockstep is the union of all the
final sets.


## Find Symmetries
First creates a graph of the formula. Then applies a graph
automorphism finder to find symmetries in the graph. Finally, it is
able to create a permutation that corresponds to symmetric
assignments.

## Symmetry Breaking Predicates

## Verification
*Verify* takes as inputs the pre- and post-conditions, and three sets;
, one with the current programs under analysis, one with
the programs that are curretly at a loop, and one with the programs that
are currently at a conditional statement.
Uses strongest postcondition computation to compute the next Hoare triple
and when it comes across a loop or if condition, it places the program to 
the respective set.

After the first set is empty, the algorithm processes the loops.
The loop process behaves like *checklockstep* but also computes postconditions.
AFter finishing the loop processing, the algorithm calls again *Verify* with
empty loops and a new precondition.

When loops and normal verification sets are empty, the algorithm handles 
conditionals (*HandleIfs*). *HandleIfs* exploits symmetries and uses SBPs to
reduce the number of generated problems and then calls *Verify*.

## Tool
The tool **Synonym** is build on another tool, **Descartes**.


## Evaluation
Compares **Synonym** with **Descartes** and **Syn** (does implement
symmetry breaking) with regards to the time and the number of
processed Hoare triples.

Benchmarks:
- Stackoverflow benchmarks (larger): **Symmetry** causes an overhead.
- Modified stackoverflow benchmarks (larger): **Syn** and **Symmetry**
  outperform **Descartes**

